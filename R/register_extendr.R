#' Register the extendr module of a package with R
#'
#' This function generates wrapper code corresponding to the extendr module
#' for an R package. This is useful in package development, where we generally
#' want appropriate R code wrapping the Rust functions implemented via extendr.
#'
#' To run `register_extendr()`, the R package containing extendr code must have
#' previously been compiled and installed. If this condition is met, the
#' wrapper code will be retrieved from the compiled Rust code and saved into
#' `R/extendr-wrappers.R`. Afterwards, you will have to re-document and then
#' re-install the package for the wrapper functions to take effect.
#' @param path File path to the package for which to generate wrapper code.
#' @param quiet Logical indicating whether any progress messages should be
#'   generated or not.
#' @param force_wrappers Logical indicating whether to generate a minimal
#'   wrapper in the cases when the package's namespace cannot be loaded. This is
#'   useful to recover the wrapper file when something is wrong with it.
#' @return The generated wrapper code. Note that this is not normally needed,
#' as the function saves the wrapper code to `R/extendr-wrappers.R`.
#' @export
register_extendr <- function(path = ".", quiet = FALSE, force_wrappers = FALSE) {
  x <- desc::desc(rprojroot::find_package_root_file("DESCRIPTION", path = path))
  pkg_name <- x$get("Package")

  if (!isTRUE(quiet)) {
    message(glue("Generating extendr wrapper functions for package: {pkg_name}"))
  }

  entrypoint_c_file <- rprojroot::find_package_root_file("src", "entrypoint.c", path = ".")
  if (!file.exists(entrypoint_c_file)) {
    stop(
      "Could not find file `src/entrypoint.c`. Are you sure this package is using extendr Rust code?",
      call. = FALSE
    )
  }

  src_dir <- rprojroot::find_package_root_file("src", path = path)
  outfile <- rprojroot::find_package_root_file("R", "extendr-wrappers.R", path = path)

  success <- make_wrappers(src_dir, outfile, quiet = quiet)

  # If it succeeds, exit early. Otherwise, try generating the wrapper via .Call().
  if (success) {
    return(invisible(TRUE))
  }

  # If force_wrappers is TRUE, use tryCatch() to generate minimal wrappers even
  # when there's some error (e.g. the symbol cannot be found).
  # If FALSE, execute make_wrappers() only when the package can be loaded.
  if (isTRUE(force_wrappers)) {
    tryCatch(
      make_wrappers(pkg_name, pkg_name, outfile, use_symbols = TRUE, quiet = quiet),
      error = function(...) {
        warning(
          "Generating the wrapper functions failed, so a minimal one is used instead",
          call. = FALSE
        )
        make_example_wrappers(pkg_name, outfile)
      }
    )
  } else if (requireNamespace(pkg_name, quietly = TRUE)) {
    make_wrappers_fallback(pkg_name, pkg_name, outfile, use_symbols = TRUE, quiet = quiet)
  } else {
    stop(
      glue("Package {pkg_name} cannot be loaded. No wrapper functions were generated."),
      call. = FALSE
    )
  }
}

make_wrappers <- function(src_dir, outfile, quiet = FALSE) {
  # Try generating extendr-wrappers.R. Even if this doesn't succeed, do not stop
  # here because it might be generated by some other means.
  exit_code <- system2("make", c("-C", src_dir, "-f", "Makevars", "extendr-wrappers.R"))
  if (exit_code != 0L) {
    warning(
      "Re-generating wrappers failed. Does src/Makevars have `extendr-wrappers.R` target?",
      call. = FALSE
    )
  }

  # Try to find the generated wrapper file. Even if this doesn't exist, do not
  # stop here and retry outside of this function.
  wrappers_file <- file.path(src_dir, "extendr-wrappers.R")
  if (!file.exists(wrappers_file)) {
    warning(
      "It seems file `src/extendr-wrappers.R` is not generated yet.",
      call. = FALSE
    )
    return(FALSE)
  }

  if (!isTRUE(quiet)) {
    message("Copying wrappers to:\n", outfile)
  }

  success <- file.copy(wrappers_file, outfile, overwrite = TRUE)

  # If copying is failed, raise an error because some unexpected thing is happening
  if (!success) {
    stop("Failed to copy wrappers.", call. = FALSE)
  }

  TRUE
}

make_wrappers_fallback <- function(module_name, package_name, outfile,
                          use_symbols = FALSE, quiet = FALSE) {
  wrapper_function <- glue("wrap__make_{module_name}_wrappers")
  x <- .Call(
    wrapper_function,
    use_symbols = use_symbols,
    package_name = package_name,
    PACKAGE = package_name
  )
  x <- stringi::stri_split_lines1(x)

  if (!isTRUE(quiet)) {
    message("Writing wrappers to:\n", outfile)
  }
  brio::write_lines(x, outfile)
}
