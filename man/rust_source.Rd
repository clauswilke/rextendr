% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/source.R
\name{rust_source}
\alias{rust_source}
\alias{rust_function}
\title{Compile Rust code and call from R}
\usage{
rust_source(
  file,
  code = NULL,
  dependencies = NULL,
 
    patch.crates_io = c("extendr-api = { git = \\"https://github.com/extendr/extendr\\" }",
    "extendr-macros = { git = \\"https://github.com/extendr/extendr\\" }"),
  profile = c("dev", "release"),
  toolchain = NULL,
  extendr_version = "*",
  extendr_macros_version = extendr_version,
  env = parent.frame(),
  use_extendr_api = TRUE,
  cache_build = TRUE,
  quiet = FALSE
)

rust_function(code, env = parent.frame(), ...)
}
\arguments{
\item{file}{Input rust file to source.}

\item{code}{Input rust code, to be used instead of \code{file}.}

\item{dependencies}{Character vector of dependencies lines to be added to the
\code{Cargo.toml} file.}

\item{patch.crates_io}{Character vector of patch statements for crates.io to
be added to the \code{Cargo.toml} file.}

\item{profile}{Rust profile. Can be either \code{"dev"} or \code{"release"}. The default,
\code{"dev"}, compiles faster but produces slower code.}

\item{toolchain}{Rust toolchain. The default, \code{NULL}, compiles with the
system default toolchain. Accepts valid Rust toolchain qualifiers,
such as \code{"nightly"}, or (on Windows) \code{"stable-msvc"}.}

\item{extendr_version}{Version of the extendr-api crate, provided as a Rust
version string. \code{"*"} will use the latest available version on crates.io.}

\item{extendr_macros_version}{Version of the extendr-macros crate, if different
from \code{extendr_version}.}

\item{env}{The R environment in which the wrapping functions will be defined.}

\item{use_extendr_api}{Logical indicating whether \verb{use extendr_api::*;} should
be added at the top of the Rust source provided via \code{code}. Default is \code{TRUE}.
Ignored for Rust source provided via \code{file}.}

\item{cache_build}{Logical indicating whether builds should be cached between
calls to \code{\link[=rust_source]{rust_source()}}.}

\item{quiet}{Logical indicating whether compile output should be generated or not.}

\item{...}{Other parameters handed off to \code{\link[=rust_source]{rust_source()}}.}
}
\value{
The result from \code{\link[=dyn.load]{dyn.load()}}, which is an object of class \code{DLLInfo}. See
\code{\link[=getLoadedDLLs]{getLoadedDLLs()}} for more details.
}
\description{
\code{\link[=rust_source]{rust_source()}} compiles and loads a single Rust file for use in R. \code{\link[=rust_function]{rust_function()}}
compiles and loads a single Rust function for use in R.
}
\examples{
\dontrun{
# creating a single rust function
rust_function("fn add(a:f64, b:f64) -> f64 { a + b }")
add(2.5, 4.7)

# creating multiple rust functions at once
code <- r"(
#[extendr]
fn hello() -> &'static str {
    "Hello, world!"
}

#[extendr]
fn test( a: &str, b: i64) {
    rprintln!("Data sent to Rust: {}, {}", a, b);
}
)"

rust_source(code = code)
hello()
test("a string", 42)


# use case with an external dependency: a function that converts
# markdown text to html, using the `pulldown_cmark` crate.
code <- r"(
  use pulldown_cmark::{Parser, Options, html};

  #[extendr]
  fn md_to_html(input: &str) -> String {
    let mut options = Options::empty();
    options.insert(Options::ENABLE_TABLES);
    let parser = Parser::new_ext(input, options);
    let mut output = String::new();
    html::push_html(&mut output, parser);
    output
  }
)"
rust_source(code = code, dependencies = 'pulldown-cmark = "0.8"')

md_text <- "# The story of the fox
The quick brown fox **jumps over** the lazy dog.
The quick *brown fox* jumps over the lazy dog."

md_to_html(md_text)
}
}
